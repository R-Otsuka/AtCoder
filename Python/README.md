## 環境構築

-

## 全体像

https://qiita.com/e869120/items/f1c6f98364d1443148b3#1-5-%E8%8C%B6%E8%89%B2%E3%82%B3%E3%83%BC%E3%83%80%E3%83%BC%E3%81%A7%E8%A6%81%E6%B1%82%E3%81%95%E3%82%8C%E3%82%8B-4-%E3%81%A4%E3%81%AE%E3%81%93%E3%81%A8

## こちらの問題集

https://qiita.com/KoyanagiHitoshi/items/c5e82841b8d0f750851d

## next step

ここまで解いたら
https://qiita.com/drken/items/fd4e5e3630d0f5859067#%E3%81%93%E3%81%93%E3%81%BE%E3%81%A7%E8%A7%A3%E3%81%84%E3%81%9F%E3%82%89
https://qiita.com/e869120/items/acba3dd8649d913102b5

# 計算量オーダー

## 超ざっくり知りたい計算量の話

https://qiita.com/colum2131/items/c765d404346b2547a43a

### O(N)

「1 ＋ 2 ＋・・・」と n 回のステップ数が掛かったため計算量は O(N)
入力サイズ N に比例

### O(N2)O(N2)

```
for i in range(1, n+1):
    for j in range(1, n+1):
        ans += i * j
print(ans)
```

計算量は N の 2 乗に比例する。

for 文が二つある場合の計算量は O(N)
これは次数のみ考慮で、係数は無視するため。

### timeOut の基準

1 秒間に処理できるステップ数はおよそ 10**8 回
1≦N≦10**7 の O(N)は大体通る。

しかし Python はスクリプト言語(遅い)ため、必ずしもこの通りではない。
(※)そもそも AtCoder の実行マシンのスペック

### その他メソッドの計算量

sort メソッドの計算量は O(NlogN)

### 計算量を落とすには

- 問題によっては線形探索を 2 分探索にして計算量を落としたり、しゃくとり法や累積和で効率良く配列の部分和を求めたりと計算量を落とす工夫は数多くあります。

- PyPy を使う。
